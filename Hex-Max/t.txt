1A81
9


FFFEA97B55
# Aktioniert werden
            if wegnehmen > hinzufügen:  # es sind zu viele Sticks im Ziffersystem
                for _ in range(wegnehmen - hinzufügen):  # für jedes zu viele Stick
                    if len(requests) > 0:  # es gibt mangel in anderen Ziffersystemen
                        # weist den überschüssigen Stick zu einer Ziffer mit einem Stickmangel zu
                        annehmende_ziffer = ziffern[requests[0]]
                        annehmende_ziffer.bekommt_von.append(aktuelle_ziffer_index)
                        o = requests.pop(0)
                        # Makierungen werden in ein Logbuch geschrieben
                        log2.append((requests, o))
                        log.append((annehmende_ziffer.bekommt_von, aktuelle_ziffer_index))
                    else:  # es gibt keine Annehmende Ziffern
                        offers.append(aktuelle_ziffer_index)  # Ziffer bietet seinen Stick an
                        log.append((offers, aktuelle_ziffer_index))  # logbuch
                        aktionen += 1
            elif hinzufügen > wegnehmen:  # es sind zu wenige Sicks im Ziffernsystem
                for _ in range(hinzufügen - wegnehmen):  # für jeden fehlenden Stick
                    if len(offers) > 0:  # es gibt Angebote
                        # Speichert von welcher Ziffer diese Ziffer den fehlenden Stick erhält
                        anbietende_ziffer_id = offers[0]
                        aktuelle_ziffer.bekommt_von.append(anbietende_ziffer_id)
                        o = offers.pop(0)
                        # aktionen ins Loguch schreiben
                        log2.append((offers, o))
                        log.append((aktuelle_ziffer.bekommt_von, anbietende_ziffer_id))
                    else:  # es gibt keine Angebote
                        # meldet einen Request
                        requests.append(aktuelle_ziffer_index)
                        log.append((requests, aktuelle_ziffer_index))  # logbuch
                        aktionen += 1

# FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEB8DE88BAA8ADD888898E9BA88AD98988F898AB7AF7BDA8A61BA7D4AD8F888
# FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEB8DE88BAA8ADD888898E9BA88AD98988F898AB7AF7BDA8A61BA7D4AD8F888
# FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEB8DE88BAA8ADD888898E9BA88AD98988F898AB7AF7BDA8A61BA7D4AD8F888
Haugen has leaked one Facebook study that found that 13.5% of U.K. teen girls in one survey say their suicidal thoughts became more frequent after starting on Instagram.
Another leaked study found 17% of teen girls say their eating disorders got worse after using Instagram.
About 32% of teen girls said that when they felt bad about their bodies, Instagram made them feel worse, Facebook's researchers found, which was first reported by the Journal.


===================


import performance_analysing

# region performance
perf = performance_analysing.time_analysing()

dbug = 0


def timer_start():
    perf.set_time_point("Start")
    print()


def timer_stop():
    print()
    perf.set_time_point("Stop")


# endregion

# region Finished
class Ziffer:
    """
        Eine Ziffer hat 7 positionen mit die mit stichen belegt werden können
          _0_
        3|_1_|4
        5|_2_|6

         _
        |_  = F =^ [1,1,0,1,0,1,0] // 1 = True; 0 = False
        |

        wir erstellen Listen die die Hexadezimalzahlen abbilden können.
        """
    models = {
        '0': [True, False, True, True, True, True, True],
        '1': [False, False, False, False, True, False, True],
        '2': [True, True, True, False, True, True, False],
        '3': [True, True, True, False, True, False, True],
        '4': [False, True, False, True, True, False, True],
        '5': [True, True, True, True, False, False, True],
        '6': [True, True, True, True, False, True, True],
        '7': [True, False, False, False, True, False, True],
        '8': [True, True, True, True, True, True, True],
        '9': [True, True, True, True, True, False, True],
        'A': [True, True, False, True, True, True, True],
        'B': [False, True, True, True, False, True, True],
        'C': [True, False, True, True, False, True, False],
        'D': [False, True, True, False, True, True, True],
        'E': [True, True, True, True, False, True, False],
        'F': [True, True, False, True, False, True, False]
    }

    def __init__(self, char, _id):
        self.id = _id
        self.positions = Ziffer.models[char][:]  # kopiere die Instanz sodass keine Referenz mehr entsteht
        self.bekommt_von = []
        self.useless_indeces = []
        self.char = char
        self.ursprungschar = char
        self.active = False
        self.char_i = 0

    def aktionen_zum_ziel(self, ziel_char):
        """
        Gibt informationen wie viele Sticks falsch an ihren Platz sind und unterteilt das in
        Falsch weil stick Fehlt und Falsch weil Stick nicht da sein dürfte
        :param ziel_char:
        :return: wegnehmen, hinzufügen (für übergebenen char)
        """
        self.char = ziel_char  # setzt den char wert zum ziel
        model = Ziffer.models[ziel_char]
        wegnehmen = 0
        hinzulegen = 0
        self.useless_indeces.clear()
        for i in range(7):
            if not model[i] == self.positions[i]:
                if model[i]:
                    hinzulegen += 1
                else:
                    wegnehmen += 1
                    self.useless_indeces.append(i)  # sticks müssen von Pos weggenommen werden
        return wegnehmen, hinzulegen

    def aktionen_log_zum_ziel(self):
        model = Ziffer.models[self.char]
        wegnehmen = 0
        hinzulegen = 0
        leerepositionen = []

        for i in range(7):
            if not model[i] == self.positions[i]:
                if model[i]:
                    hinzulegen += 1
                    leerepositionen.append(i)
                else:
                    wegnehmen += 1

        t_logs = []
        sources = [self.id for _ in range(wegnehmen)] + self.bekommt_von

        for p in leerepositionen:
            gebenden_ziffer_id = sources.pop(-1)
            log = self.id, p, gebenden_ziffer_id, ziffern[gebenden_ziffer_id].useless_indeces.pop(-1)
            t_logs.append(log)
        return t_logs

    def __str__(self):
        return self.char


class Char_information_Dict2D:

    def __init__(self):
        self.value = {}

    def __contains__(self, item):
        return item in self.value

    def key_exists(self, key1, key2=None):
        if not key1 in self.value:
            return False
        if key2 is not None and key2 not in self.value[key1]:
            return False
        return True

    def get_value(self, key1, key2=None):
        if not key1 in self.value:
            print("Error")
        if key2 is None:
            return self.value[key1]
        if key2 not in self.value[key1]:
            raise
        return self.value[key1][key2]

    def set_value(self, key1, key2, value):
        if key1 not in self.value:
            self.value[key1] = {key2: value}
        else:
            self.value[key1][key2] = value


def get_input(pfad):
    text = open(pfad, "r").read()
    zeilen = text.split("\n")
    zeilen.pop(-1)
    #
    ziffern = []  # sammelt alle Ziffern
    print(zeilen[0])
    i = 0
    for char in zeilen[0]:
        ziffern.append(Ziffer(char, i))
        i += 1
    aktionen = int(zeilen[1])
    print("Aktionen", aktionen)
    return ziffern, aktionen


def print_ziffern(list_ziffern):  # printet die momentane Anordnung der Sticks
    zeile_1 = ""
    zeile_2 = ""
    zeile_3 = ""

    for ziffer in list_ziffern:
        zeile_1 += f" {'_' if ziffer.positions[0] else ' '}  "
        zeile_2 += f"{'|' if ziffer.positions[3] else ' '}{'_' if ziffer.positions[1] else ' '}{'|' if ziffer.positions[4] else ' '} "
        zeile_3 += f"{'|' if ziffer.positions[5] else ' '}{'_' if ziffer.positions[2] else ' '}{'|' if ziffer.positions[6] else ' '} "

    print("____")
    print(zeile_1)
    print(zeile_2)
    print(zeile_3)
    print()


def aktionen_bezogen_auf_situation(start_char, zielchar, offers, requests):
    """
    Findet heraus wie viele aktionen wirklich getan werden müssen und berücksichtigt dabei schon beiseite gelegte sticks
    :param wegnehmen:
    :param hinzufügen:
    :param aktuelle_ziffer_index:
    :param aktuelle_ziffer:
    :return: aktionen, removes, appends
    """
    global tabelle
    inf = tabelle[start_char][zielchar]
    aktionen = inf.min_aktion  # es müssen mindetens die unter einander zu tauschenden sticks

    if inf.stick_mangel > 0:  # es wird aus offers genommen
        if offers > 0:
            offers -= inf.stick_mangel  # 0.remove(1)
            if offers < 0:
                aktionen += abs(offers)
                offers = 0
    elif inf.stick_mangel < 0:  # es wird aus requests genommen
        if requests > 0:
            requests += inf.stick_mangel
            if requests < 0:
                aktionen += abs(offers)
                requests = 0
    return aktionen, offers, requests

    """
def aktionen_bezogen_auf_situation(char, aktuelle_ziffer_index, aktuelle_ziffer):

    Findet heraus wie viele aktionen wirklich getan werden müssen und berücksichtigt dabei schon beiseite gelegte sticks
    :param wegnehmen:
    :param hinzufügen:
    :param aktuelle_ziffer_index:
    :param aktuelle_ziffer:
    :return: aktionen, removes, appends

    global tabelle
    inf = tabelle[aktuelle_ziffer.ursprungschar][char]

    aktionen = inf.min_aktion  # es müssen mindetens die unter einander zu tauschenden sticks
    removes = []  # log = [(list, objekt)] later remove objekt from list
    appends = []  # log2 = [(list, objekt)] later append objekt to list
    for _ in range(abs(inf.stick_mangel)):
        if inf.stick_mangel > 0:  # es wird aus offers genommen
            if len(offers) > 0:
                o = offers.pop(-1) # TODO need to make sure that if its poped the item which is poped is either removed from the other
                aktuelle_ziffer.bekommt_von.append(o)
                appends.append((offers, o))  # 0.append(1)
                removes.append((aktuelle_ziffer.bekommt_von, o))  # 0.remove(1)
            else:
                requests.append(aktuelle_ziffer_index)
                removes.append((requests, aktuelle_ziffer_index))  # 0.remove(1)
                aktionen += 1
        elif inf.stick_mangel < 0:  # es wird aus requests genommen
            if len(requests) > 0:
                o = requests.pop(-1)
                ziffern[o].bekommt_von.append(aktuelle_ziffer_index)
                appends.append((requests, o))  # 0.append(1)
                removes.append((ziffern[o].bekommt_von, aktuelle_ziffer_index))  # 0.remove(1)
            else:
                offers.append(aktuelle_ziffer_index)
                removes.append((offers, aktuelle_ziffer_index))  # 0.remove(1)
                aktionen += 1
    aktuelle_ziffer.char = char
    aktuelle_ziffer.useless_indeces = inf.useless_indeces.copy()
    return aktionen, removes, appends
    """


def undo_action(start_char, zielchar, aktionen_übrig, offers, requests):
    """
    Findet heraus wie viele aktionen wirklich getan werden müssen und berücksichtigt dabei schon beiseite gelegte sticks
    :param wegnehmen:
    :param hinzufügen:
    :param aktuelle_ziffer_index:
    :param aktuelle_ziffer:
    :return: aktionen, removes, appends
    """
    global tabelle
    inf = tabelle[start_char][zielchar]
    aktionen = inf.min_aktion  # es müssen mindetens die unter einander zu tauschenden sticks

    if inf.stick_mangel > 0:  # es wird aus offers genommen
        if offers > 0:
            offers -= inf.stick_mangel  # 0.remove(1)
            if offers < 0:
                aktionen += abs(offers)
                offers = 0
    elif inf.stick_mangel < 0:  # es wird aus requests genommen
        if requests > 0:
            requests += inf.stick_mangel
            if requests < 0:
                aktionen += abs(offers)
                requests = 0

    return aktionen_übrig, offers, requests


def ausgabe():
    print("Ergebnis:\nEnd-Hexadezimalzahl")
    for ziff in ziffern:
        print(ziff.char, end="")
    print("\nAusgangssituation:")
    print_ziffern(ziffern)
    a = 1
    for az in ziffern:
        logs = az.aktionen_log_zum_ziel()

        for log in logs:
            """
            az_id: Id der stick-annehmenden Ziffer
            az_sp: Stickposition im Ziffernsystem der stick-annehmenden Ziffer
            gz_id: Id der stick-abgebenden Ziffer
            gz_sp: Stickposition im Ziffernsystem der stick-abgebenden Ziffer
            """
            az_id, az_sp, gz_id, gz_sp = log
            # tauscht sticks zwischen den beiden
            ziffern[az_id].positions[az_sp], ziffern[gz_id].positions[gz_sp] = ziffern[gz_id].positions[gz_sp], \
                                                                               ziffern[az_id].positions[az_sp]
            print_ziffern(ziffern)
            print("Das war Aktion", a)
            a += 1


def gen_tabelle():
    t = {}
    ziffern_ = []
    for i in range(len(versuchsliste)):
        ziffern_.append(Ziffer(versuchsliste[i], i))

    for z in ziffern_:
        temp = {}
        for char in versuchsliste:
            wegnehmen, hinzulegen = z.aktionen_zum_ziel(char)
            temp[char] = Ziffern_change_information(wegnehmen, hinzulegen, z.useless_indeces.copy())
        t[z.ursprungschar] = temp
    return t


def Undo_Log(log, index):
    global dbug
    dbug += 1
    if dbug == 26165 or dbug == 253090:  # some how it cant
        print("sas")
    print(dbug)  # 4: 60865
    aktionen, removes, appends = log
    for a, b in removes: a.remove(b)
    for a, b in appends: a.append(b)

    ziffern[index].char = ziffern[index].ursprungschar
    return aktionen


def maximiere_ziffern_iter(versuchsliste, aktionen_übrig, offers, requests, ziffern):
    _index = 0
    logs = [None for _ in range(len(ziffern))]
    mögliche_ausgleiche = Char_information_Dict2D()
    while True:
        if _index == len(ziffern):
            if 0 == offers == requests: break
            _index -= 1
            continue

        aktuelle_ziffer = ziffern[_index]  # betrachtete aktuelle Ziffer
        if not aktuelle_ziffer.active:
            if aktionen_übrig == 0:
                if 0 == offers == requests: break
                _index -= 1
                continue

            # brauchste eig net
            if aktuelle_ziffer.char_i == len(versuchsliste):
                # input("Dein onkel numst")
                aktuelle_ziffer.char_i = 0
                aktuelle_ziffer.active = False
                _index -= 1
                continue

            char = versuchsliste[aktuelle_ziffer.char_i]  # iteriert durch alle Hex-Zahlen durch
            aktionen, offers, requests = aktionen_bezogen_auf_situation(aktuelle_ziffer.ursprungschar, char, offers,
                                                                        requests)
            aktionen_übrig -= aktionen
            if aktionen_übrig < 0:
                aktionen_übrig, offers, requests = undo_action(aktuelle_ziffer.ursprungschar, char, offers, requests,
                                                               aktionen)
                aktuelle_ziffer.char_i += 1
                continue

            if mögliche_ausgleiche.key_exists(_index + 1, aktionen_übrig):
                zielausgleich = offers + requests
                ausgleichswert = mögliche_ausgleiche.get_value(_index + 1, aktionen_übrig)
                if ausgleichswert < zielausgleich:
                    print("not trying", _index + 1, "because psnl eq", ausgleichswert, "<",
                          zielausgleich, "goal")
                    aktionen_übrig, offers, requests = undo_action(aktuelle_ziffer.ursprungschar, char, offers,
                                                                   requests,
                                                                   aktionen)
                    aktuelle_ziffer.char_i += 1
                    continue
            logs[_index] = (aktionen, removes, appends)
            aktuelle_ziffer.active = True
            _index += 1
        else:

            # nun wird überprüft, ob ein Ausgleich noch möglich ist der übrigen stäbchen möglich ist
            ausgleich_möglich, n_maximal_ausgeglichen = ausgleich_der_stäbchen_iter(_index + 1,
                                                                                    aktionen_übrig, ziffern)

            if ausgleich_möglich: break
            if not mögliche_ausgleiche.key_exists(_index + 1, aktionen_übrig):
                mögliche_ausgleiche.set_value(_index + 1, aktionen_übrig, n_maximal_ausgeglichen)
            # wenn der danach nicht geklappt hat wird versucht die momentane Stellung irgendwie möglich zu machen

            # aktionen Rückgängig machen
            aktionen_übrig += Undo_Log(logs[_index], _index)
            aktiv[_index] = False
            char_i[_index] += 1
    return True


# endregion


def ausgleich_der_stäbchen_iter(index, aktionen_übrig, ziffern):  # TODO not removing in the right way
    """
    Diese Funktion verteilt beiseite gelegte Sticks auf die restlichen
    Ziffernsysteme so das dabei auch noch eine maximale Hexadezimalzahl entsteht
    :param index: index der letzten festgelegten ziffer
    :return: Erfolg (bool)
    """
    char_i = [0 for _ in range(len(ziffern))]
    logs_: list[tuple[int, list, list]] = [None for _ in range(len(ziffern))]
    aktiv = [False for _ in range(len(ziffern))]
    start_index = index
    ausgleichsvalues = Char_information_Dict2D()
    while start_index <= index:
        zielausgleich = len(offers) + len(requests)
        if index == len(ziffern):
            if zielausgleich == 0: return True, 0
            ausgleichsvalues.set_value(index, aktionen_übrig, 0)
            index -= 1
            continue

        if not aktiv[index]:  # first touch
            if zielausgleich == 0: return True, 0
            aktuelle_ziffer = ziffern[index]  # betrachtete aktuelle Ziffer
            ci = char_i[index]
            if ci == len(versuchsliste):  # every char was checked
                char_i[index] = 0
                aktiv[index] = False
                index -= 1
                continue
            char = versuchsliste[ci]
            aktionen, offers, requests = aktionen_bezogen_auf_situation(char, index, aktuelle_ziffer)
            base_aktionen = aktionen_übrig
            aktionen_übrig -= aktionen

            new_zielausgleich = len(offers) + len(requests)
            if aktionen_übrig < 0:
                aktionen_übrig += Undo_Log((aktionen, removes, appends), index)
                char_i[index] += 1
                continue
            max_ausgleich = 0  # will only be 0 if ausgleichsvalues.key_exists(index + 1, aktionen_übrig) == False
            if ausgleichsvalues.key_exists(index + 1, aktionen_übrig):
                max_ausgleich = ausgleichsvalues.get_value(index + 1, aktionen_übrig)
                if max_ausgleich < new_zielausgleich:
                    aktionen_übrig += Undo_Log((aktionen, removes, appends), index)
                    char_i[index] += 1
                    continue
            # ist das der char der den höchsten ausgleich macht?
            gewonnener_ausgleich = zielausgleich - new_zielausgleich
            if not ausgleichsvalues.key_exists(index, base_aktionen):
                ausgleichsvalues.set_value(index, base_aktionen,
                                           max(gewonnener_ausgleich, 0))  # u can set it 0 by default because
                # there is always the chance to keep the char at its state
            elif ausgleichsvalues.get_value(index, base_aktionen) <= gewonnener_ausgleich + max_ausgleich:
                # set this new max value only if
                ausgleichsvalues.set_value(index, base_aktionen, gewonnener_ausgleich + max_ausgleich)

            aktiv[index] = True
            logs_[index] = (aktionen, removes, appends)
            index += 1

        else:  # second touch
            # wenn der danach nicht geklappt hat wird versucht die momentane Stellung irgendwie möglich zu machen
            aktionen_übrig += Undo_Log(logs_[index], index)
            # aktionen Rückgängig machen
            aktiv[index] = False
            char_i[index] += 1
    return False, ausgleichsvalues.get_value(start_index, aktionen_übrig)


class Ziffern_change_information:

    def __init__(self, weg, hin, useless_i):
        self.min_aktion = min(weg, hin)
        self.weg = weg
        self.hin = hin
        self.stick_mangel = hin - weg
        self.useless_indeces = useless_i

    def __eq__(self, other):
        return self.weg == other.weg and self.hin == other.hin and self.useless_indeces == other.useless_indeces


timer_start()
pfad = "hexmax5.txt"
if __name__ == '__main__':
    """
    Definitionen:
    - Ziffer: Eine Instanz der Klasse Ziffer, enthält Informationen über ob die "Sticks" an einer Position sind
    - Ziffersystem: Meint die möglichen Postionen in einer Ziffer

    FFFC438B55
    FFFC997B95
     _   _   _   _   _   _   _       _   _
    |_  |_  |_  |   |_| |_|   | |_  |_| |_
    |   |   |   |_   _|  _|   | |_|  _|  _|
    """
    versuchsliste = "FEDCBA9876543210"  # Hex-Zahlen zum durch iterieren
    tabelle = gen_tabelle()  # tabelle[goalchar][startchar]
    ziffern, aktionen_übrig = get_input(pfad)  # input aus Text-Datei
    offers = 0  # liste von ziffer_ids dessen ziffer striche zur verfügen stellen
    requests = 0  # liste von ziffer_ids dessen ziffer striche Anfragen
    maximiere_ziffern_iter(versuchsliste, aktionen_übrig, offers, requests, ziffern)  # haupt funktion

    ausgabe()

timer_stop()

"""
Idee 1.0

überprüfe wie viele Streichhölzer du zur verfügung hast:

Schau wie du eine Ziffer erhöhen kannst wenn du Hölzer weg nimmst
Mach dies für jede Ziffer - die anzahl an weggenommenen Streichhölzern heißt profit_streichhölzer

Wenn die Anzahl an profit_streichhölzern kleiner ist als die Anzahl an verfügbaren aktionen_übrig, müssen wir davon ausgehen
dass diese streichhölzer nicht ausreichen werden. Es muss also Ziffern geben die an wert verlieren.

Wenn das der Fall ist brauchen wir eine Andere Strategie:
    wir berechnen die Anzahl an streichhölzern die wir allgemein durchs weg nehmen erhalten können.

Die erste Ziffer wird versucht so hoch,
Deshalb wird ab dem Punkt wo alle verfügbaren Streichhölzer versuchen wir

-----
Der ansatz ist die ersten Ziffern so weit zu optimieren wie es geht
im ideal Fall ist es also FFFFFFFFFF...F1213B34

Umsetzung

"""  # Idee 1.0

"""
Idee 2.0

Jede gegeben Ziffer  des Hexadezimalsystems wird versucht zur höchst möglichen Ziffer umgewandelt zu werden.
n = 0
1. Stelle n versuchen zu erst zu (ziffer z) F dann E,D,C,B... bis zum Wert des eigenen Ziffer value,  umgewandelt zu werden
-> daraus kann das Problem folgen das Stäbchen übrig sind oder gebrauch werden.
-> Jetzt Schreiben wir einen Algorithmus der um jeden Preis versucht diesen Mangel/Überschuss zu kompensieren.
    # Hierzu können auch schon die im Request oder Pott verfügbaren Stäbchen verwendet werden.
-> Gelingt dies innerhalb der verfügbaren aktionen_übrig.
    wird die Ziffer n fest der Ziffer z zu geschrieben. Gehe zu schritt 2.
-> Gelingt dies nicht wird die nächste ziffer z versucht. => 1

2. Nun wird optimiert:
-> Es wird ausgerechnet wie viele Aktionen sicher getätigt werden müssen und der überschuss wird in eine Pott-Liste und der Mangel in einer Request-Liste abgespeichert
n++;=> gehe zu schritt 1.
    # wenn n das maximum erreicht hat gehe zu => 3.

3.
weise so effizient wie es geht die stäbchen den Ziffern zu und schreibe für jede Aktion einen Log
"""  # idee 2.0

"""
__Idee 3.0

Eine Mischung aus 1.0 und 2.0

Die Möglchkeiten werden gebruteforced nur das vom Bestcasesceniario (FFFFFF...F) ausgegangen wird (1.0).
Sobald eine Ziffer die verfügbaren Aktionen ausgeschöpft hat, wird nachgeprüft ob diese Ziffer allgemein als
letztmögliche verfügbar ist. (2.0)

"""  # idee 3.0 aktuellste

=========================== Backup 28.03.2022 ===============================
import performance_analysing

# region performance
perf = performance_analysing.time_analysing()


def timer_start():
    perf.set_time_point("Start")
    print()


def timer_stop():
    print()
    perf.set_time_point("Stop")


# endregion

# region Finished
class ZifferSystem:
    """
        Eine Ziffer hat 7 positionen mit die mit stichen belegt werden können
          _0_
        3|_1_|4
        5|_2_|6

         _
        |_  = F =^ [1,1,0,1,0,1,0] // 1 = True; 0 = False
        |

        wir erstellen Listen die die Hexadezimalzahlen abbilden können.
        """
    models = {
        '0': [True, False, True, True, True, True, True],
        '1': [False, False, False, False, True, False, True],
        '2': [True, True, True, False, True, True, False],
        '3': [True, True, True, False, True, False, True],
        '4': [False, True, False, True, True, False, True],
        '5': [True, True, True, True, False, False, True],
        '6': [True, True, True, True, False, True, True],
        '7': [True, False, False, False, True, False, True],
        '8': [True, True, True, True, True, True, True],
        '9': [True, True, True, True, True, False, True],
        'A': [True, True, False, True, True, True, True],
        'B': [False, True, True, True, False, True, True],
        'C': [True, False, True, True, False, True, False],
        'D': [False, True, True, False, True, True, True],
        'E': [True, True, True, True, False, True, False],
        'F': [True, True, False, True, False, True, False]
    }

    def __init__(self, char, _id):
        self.id = _id
        self.positions = ZifferSystem.models[char][:]  # kopiere die Instanz sodass keine Referenz mehr entsteht
        self.bekommt_von = []
        self.useless_indeces = []
        self.char = char
        self.ursprungschar = char
        self.active = False
        self.char_i = 0
        self.log = None

    def aktionen_zum_ziel(self, ziel_char):
        """
        Gibt informationen wie viele Sticks falsch an ihren Platz sind und unterteilt das in
        Falsch weil stick Fehlt und Falsch weil Stick nicht da sein dürfte
        :param ziel_char:
        :return: wegnehmen, hinzufügen (für übergebenen char)
        """
        self.char = ziel_char  # setzt den char wert zum ziel
        model = ZifferSystem.models[ziel_char]
        wegnehmen = 0
        hinzulegen = 0
        self.useless_indeces.clear()
        for i in range(7):
            if not model[i] == self.positions[i]:
                if model[i]:
                    hinzulegen += 1
                else:
                    wegnehmen += 1
                    self.useless_indeces.append(i)  # sticks müssen von Pos weggenommen werden
        return wegnehmen, hinzulegen

    def aktionen_log_zum_ziel(self):
        model = ZifferSystem.models[self.char]
        wegnehmen = 0
        hinzulegen = 0
        leerepositionen = []

        for i in range(7):
            if not model[i] == self.positions[i]:
                if model[i]:
                    hinzulegen += 1
                    leerepositionen.append(i)
                else:
                    wegnehmen += 1

        t_logs = []
        sources = [self.id for _ in range(wegnehmen)] + self.bekommt_von

        for p in leerepositionen:
            gebenden_ziffer_id = sources.pop(-1)
            log = self.id, p, gebenden_ziffer_id, ziffern[gebenden_ziffer_id].useless_indeces.pop(-1)
            t_logs.append(log)
        return t_logs

    def __str__(self):
        return f"{self.char} ci{self.char_i} act{self.active} log{self.log} id{self.id}"


class CharInformationDict2D:

    def __init__(self):
        self.value = {}

    def __contains__(self, item):
        return item in self.value

    def key_exists(self, key1, key2=None):
        if not key1 in self.value:
            return False
        if key2 is not None and key2 not in self.value[key1]:
            return False
        return True

    def get_value(self, key1, key2=None):
        if not key1 in self.value:
            return 0
        if key2 is None:
            return self.value[key1]
        if key2 not in self.value[key1]:
            # v = self.value[key1][key2] = self.get_value(key1+1, 0)
            return 0
        return self.value[key1][key2]

    def set_value_filtered(self, key1, key2, value):
        if key1 not in self.value:
            self.value[key1] = {key2: value}
        else:
            for k in self.value[key1].keys():
                if k > key2:
                    if self.value[key1][k][0] < value[0]:
                        self.value[key1][k][0] = value[0]
                    if self.value[key1][k][1] < value[1]:
                        self.value[key1][k][1] = value[1]
                else:
                    if self.value[key1][k][0] > value[0]:
                        value[0] = self.value[key1][k][0]
                    if self.value[key1][k][1] < value[1]:
                        value[0] = self.value[key1][k][0]

            self.value[key1][key2] = value


class ZiffernChangeInformation:

    def __init__(self, weg, hin, useless_i):
        self.min_aktion = min(weg, hin)
        self.weg = weg
        self.hin = hin
        self.stick_mangel = hin - weg
        self.useless_indeces = useless_i

    def __eq__(self, other):
        return self.weg == other.weg and self.hin == other.hin and self.useless_indeces == other.useless_indeces


def get_input(pfad):
    text = open(pfad, "r").read()
    zeilen = text.split("\n")
    zeilen.pop(-1)
    #
    ziffern = []  # sammelt alle Ziffern
    print(zeilen[0])
    i = 0
    for char in zeilen[0]:
        ziffern.append(ZifferSystem(char, i))
        i += 1
    aktionen = int(zeilen[1])
    print("Aktionen", aktionen)
    return ziffern, aktionen


def print_ziffern(list_ziffern):  # printet die momentane Anordnung der Sticks
    zeile_1 = ""
    zeile_2 = ""
    zeile_3 = ""

    for ziffer in list_ziffern:
        zeile_1 += f" {'_' if ziffer.positions[0] else ' '}  "
        zeile_2 += f"{'|' if ziffer.positions[3] else ' '}{'_' if ziffer.positions[1] else ' '}{'|' if ziffer.positions[4] else ' '} "
        zeile_3 += f"{'|' if ziffer.positions[5] else ' '}{'_' if ziffer.positions[2] else ' '}{'|' if ziffer.positions[6] else ' '} "

    print("____")
    print(zeile_1)
    print(zeile_2)
    print(zeile_3)
    print()


def try_change_char(start_char, zielchar, offers, requests):
    """
    Findet heraus wie viele aktionen wirklich getan werden müssen und berücksichtigt dabei schon beiseite gelegte sticks
    :return: aktionen, offers, requests, d_offers(zunahme), d_requests(zunahme)
    """
    global tabelle
    d_offers, d_requests = 0, 0
    bu_offers, bu_requests = offers, requests
    inf = tabelle[start_char][zielchar]
    aktionen = inf.min_aktion  # es müssen mindetens die unter einander zu tauschenden sticks
    if inf.stick_mangel > 0:  # es wird aus offers genommen
        offers -= inf.stick_mangel  # offers verringert sich
        d_offers = -inf.stick_mangel  # um wieviel offers zu genommen hat
        if offers < 0:  # es muss eine eigene request aufgegeben werden...
            aktionen -= offers  # ...das ist eine extra aktion
            requests -= offers
            # dieser muss aus dem delta entfernt werden...
            offers = 0  # ...da offers auf 0 gesetzt wird
    elif inf.stick_mangel < 0:  # es wird aus requests genommen
        requests += inf.stick_mangel  # so viele es requests werden befriedigt
        d_requests = inf.stick_mangel
        if requests < 0:  # es muss ein angebot für alle sichtbar erstellt werden
            aktionen -= requests  # das kostet
            offers -= requests  # offers erhöht sich
            requests = 0

    return aktionen, offers, requests, d_offers, d_requests, bu_offers, bu_requests


def undo_action(log, actions_left):
    aktionen, d_offers, d_requests, bu_offers, bu_requests = log
    actions_left += aktionen
    return actions_left, bu_offers, bu_requests


def aktionen_planen(aktuelle_ziffer, offers, requests, tabelle):
    inf = tabelle[aktuelle_ziffer.ursprungschar][aktuelle_ziffer.char]

    for _ in range(inf.hin if inf.weg >= inf.hin else inf.weg):
        aktuelle_ziffer.bekommt_von.append(aktuelle_ziffer.id)

    for _ in range(abs(inf.stick_mangel)):
        if inf.stick_mangel > 0:  # es wird aus offers genommen
            if len(offers) > 0:
                o = offers.pop(-1)
                aktuelle_ziffer.bekommt_von.append(o)
            else:
                requests.append(aktuelle_ziffer.id)
        elif inf.stick_mangel < 0:  # es wird aus requests genommen
            if len(requests) > 0:
                o = requests.pop(-1)
                ziffern[o].bekommt_von.append(aktuelle_ziffer.id)
            else:
                offers.append(aktuelle_ziffer.id)
    aktuelle_ziffer.useless_indeces = inf.useless_indeces.copy()
    return offers, requests


def ausgabe():
    offers_list = []
    requests_list = []
    for ziffer in ziffern:
        aktionen_planen(ziffer, offers_list, requests_list, tabelle)
    print("\nAusgangssituation:")
    print_ziffern(ziffern)
    a = 1
    for az in ziffern:
        logs = az.aktionen_log_zum_ziel()

        for log in logs:
            """
            az_id: Id der stick-annehmenden Ziffer
            az_sp: Stickposition im Ziffernsystem der stick-annehmenden Ziffer
            gz_id: Id der stick-abgebenden Ziffer
            gz_sp: Stickposition im Ziffernsystem der stick-abgebenden Ziffer
            """
            az_id, az_sp, gz_id, gz_sp = log
            # tauscht sticks zwischen den beiden
            ziffern[az_id].positions[az_sp], ziffern[gz_id].positions[gz_sp] = ziffern[gz_id].positions[gz_sp], \
                                                                               ziffern[az_id].positions[az_sp]
            print_ziffern(ziffern)
            print("Das war Aktion", a)
            a += 1
    print("Ergebnis:\nEnd-Hexadezimalzahl")
    for ziff in ziffern:
        print(ziff.char, end="")


def gen_tabelle():
    t = {}
    ziffern_ = []
    for i in range(len(versuchsliste)):
        ziffern_.append(ZifferSystem(versuchsliste[i], i))

    for z in ziffern_:
        temp = {}
        for char in versuchsliste:
            wegnehmen, hinzulegen = z.aktionen_zum_ziel(char)
            temp[char] = ZiffernChangeInformation(wegnehmen, hinzulegen, z.useless_indeces.copy())
        t[z.ursprungschar] = temp
    return t


def maximiere_ziffern_iter(versuchsliste, actions_left, offers, requests, ziffern):
    # man geht immer vom best case aus
    _index = 0
    ausgleichs_werte = CharInformationDict2D()
    while True:
        if _index == len(ziffern):  # wenn es keine Ziffern mehr zum Verändern gibt
            if 0 == offers - requests:  # win condition
                print("Es passt halt 1 Line 316")
                break
            _index -= 1  # Miserfolg
            continue

        aktuelle_ziffer = ziffern[_index]  # betrachtete aktuelle Ziffer
        if not aktuelle_ziffer.active:  # aktuelle ziffer wird betrachtet
            if actions_left == 0:  # die ziffer kann sich nicht mehr verändern nach Schema 1
                if 0 == offers - requests:  # win condition
                    print("Es passt halt 2 Line 324")
                    break
                _index -= 1  # Misserfolg
                continue

            aktuelle_ziffer.active = True  # die ziffer hier kann überprüft werden
            char = versuchsliste[aktuelle_ziffer.char_i]  # iteriert durch alle Hex-Zahlen durch
            # Simuliert das Umwandeln dieser Ziffer und returned die Situation wie sie dann aussehen wird
            aktionen, offers, requests, d_offers, d_requests, bu_offers, bu_requests = try_change_char(
                aktuelle_ziffer.ursprungschar, char,
                offers, requests)
            # macht backup von dieser Situation
            log = (aktionen, d_offers, d_requests, bu_offers, bu_requests)
            aktuelle_ziffer.log = log
            aktuelle_ziffer.char = char
            actions_left -= aktionen  # durch diesen Versuch verändert sich auch die übrigen Aktionen
            if actions_left < 0:  # wenn mehr Aktionen gebraucht als verfügbar, diese Ziffer unmöglich
                continue  # durch ziffer.active = True: im nächsten durchgang wird Überprüfungsschema2 probiert
            if ausgleichs_werte2.key_exists(_index + 1, actions_left):
                # falls schon berechnet wurde, was der maximale Ausgleichswert ist
                zielausgleich = offers + requests  # offers oder requests ist 0
                ausgleichswert = ausgleichs_werte2.get_value(_index + 1, actions_left)
                if ausgleichswert[0 if offers > 0 else 1] < zielausgleich:  # wenn der Zielausgleich nicht erreicht werden kann
                    continue  # wir wissen, dass dieser Char nicht möglich ist
            _index += 1  # nächste ziffer wird betrachtet
        else:
            # backup laden
            aktionen, d_offers, d_requests, bu_offers, bu_requests = aktuelle_ziffer.log

            if actions_left >= 0:  # nur wenn die Simulation eine potenzielle Situation erschaffen
                # nun wird überprüft, ob ein Ausgleich noch möglich ist der übrigen stäbchen möglich ist
                # man darf nicht mehr aktionen verbraucht haben als zugänglich
                ausgleichbar, n_maximal_ausgeglichen = ausgleich_der_stäbchen_iter(_index + 1,
                                                                                   actions_left, ziffern, offers,
                                                                                   requests)
                if ausgleichbar: break  # win condition

                # setzt nur, wenn es noch nicht existiert und wirklich besser ist
                #ausgleichs_werte.set_value_filtered(_index, actions_left + aktionen, n_maximal_ausgeglichen)

            # Simulation rückgängig machen
            actions_left, offers, requests = actions_left + aktionen, bu_offers, bu_requests
            aktuelle_ziffer.active = False
            aktuelle_ziffer.char_i += 1
            aktuelle_ziffer.char = aktuelle_ziffer.ursprungschar

            if aktuelle_ziffer.char_i == len(versuchsliste):
                aktuelle_ziffer.char_i = 0
                _index -= 1
    return True


def ausgleich_der_stäbchen_iter(index, actions_left, ziffern, offers, requests):
    global ausgleichs_werte2
    """
    Diese Funktion verteilt beiseite gelegte Sticks auf die restlichen
    Ziffernsysteme so das dabei auch noch eine maximale Hexadezimalzahl entsteht
    :param index: index der letzten festgelegten ziffer
    :return: Erfolg (bool)
    """

    start_index = index
    while start_index <= index:
        zielausgleich = offers + requests
        if index == len(ziffern):  # keine Ziffern mehr überprüfbar
            if zielausgleich == 0: return True, 0  # win condition
            ausgleichs_werte2.set_value_filtered(index, actions_left, [0, 0])
            index -= 1
            continue
        # betrachtete aktuelle Ziffer
        aktuelle_ziffer = ziffern[index]
        if not aktuelle_ziffer.active:  # first touch
            if zielausgleich == 0: return True, 0  # win condition

            char = versuchsliste[aktuelle_ziffer.char_i]  # char durch iterieren
            # simulation machen
            aktionen, offers, requests, d_offers, d_requests, bu_offers, bu_requests = try_change_char(
                aktuelle_ziffer.ursprungschar, char, offers, requests)
            actions_left -= aktionen
            aktuelle_ziffer.char = char
            aktuelle_ziffer.active = True
            # backup für situation
            aktuelle_ziffer.log = (aktionen, d_offers, d_requests, bu_offers, bu_requests)

            new_zielausgleich = offers + requests
            if actions_left < 0:
                continue  # dieser char funktioniert nicht, weil zu viele aktionen gebraucht werden

            if ausgleichs_werte2.key_exists(index + 1, actions_left):  # wenn wir den besten ausgleichswert
                # von den nächsten Ziffern kennen
                max_ausgleich = ausgleichs_werte2.get_value(index + 1, actions_left)
                if max_ausgleich[0 if offers > 0 else 1] < new_zielausgleich:
                    continue  # wir können diesen Char ausschließen
            index += 1  # die Nächste Ziffer wird betrachtet
        else:  # second touch
            # load the back up
            aktionen, d_offers, d_requests, bu_offers, bu_requests = aktuelle_ziffer.log

            # undo simulation
            actions_left, offers, requests = actions_left + aktionen, bu_offers, bu_requests
            aktuelle_ziffer.active = False
            aktuelle_ziffer.char = aktuelle_ziffer.ursprungschar
            aktuelle_ziffer.char_i += 1

            if ausgleichs_werte2.key_exists(index + 1,
                                            actions_left):  # wenn wir den Ausgleichswert von der nächsten Ziffer kennen
                upperwin = ausgleichs_werte2.get_value(index + 1, actions_left)  # was ist dieser Wert?
                actual_win = [(-d_offers) + upperwin[0], (-d_requests) + upperwin[1]]
                # wie hoch wäre dieser Win auf unsere Situation
                ausgleichs_werte2.set_value_filtered(index, actions_left,
                                                     actual_win)  # setzt es nur, wenn es auch wirklich besser ist

            if aktuelle_ziffer.char_i == len(versuchsliste):  # every char was checked
                aktuelle_ziffer.char_i = 0
                index -= 1
    return False, ausgleichs_werte2.get_value(start_index, actions_left)


# endregion

timer_start()

pfad = "hexmax5.txt"
if __name__ == '__main__':
    """
    Definitionen:
    - Ziffer: Eine Instanz der Klasse Ziffer, enthält Informationen über ob die "Sticks" an einer Position sind
    - Ziffersystem: Meint die möglichen Postionen in einer Ziffer

    FFFC438B55
    FFFC997B95
     _   _   _   _   _   _   _       _   _
    |_  |_  |_  |   |_| |_|   | |_  |_| |_
    |   |   |   |_   _|  _|   | |_|  _|  _|
    """
    ausgleichs_werte2 = CharInformationDict2D()
    versuchsliste = "FEDCBA9876543210"  # Hex-Zahlen zum durch iterieren
    tabelle = gen_tabelle()  # tabelle[goalchar][startchar]
    ziffern, actions_left = get_input(pfad)  # input aus Text-Datei
    offers = 0  # liste von ziffer_ids dessen ziffer striche zur verfügen stellen
    requests = 0  # liste von ziffer_ids dessen ziffer striche Anfragen
    maximiere_ziffern_iter(versuchsliste, actions_left, offers, requests, ziffern)  # haupt funktion

    ausgabe()
    print("\nout of", actions_left)

timer_stop()
